//#include <reg52.h>
#include "stdlib.h"
#include "string.h"
#include "stdio.h"

typedef unsigned short     int uint16_t;
#define     __IO    volatile 
typedef struct
{
  __IO uint16_t SR;         /*!< USART Status register,                   Address offset: 0x00 */
  uint16_t      RESERVED0;  /*!< Reserved, 0x02                                                */
  __IO uint16_t DR;         /*!< USART Data register,                     Address offset: 0x04 */
  uint16_t      RESERVED1;  /*!< Reserved, 0x06                                                */
  __IO uint16_t BRR;        /*!< USART Baud rate register,                Address offset: 0x08 */
  uint16_t      RESERVED2;  /*!< Reserved, 0x0A                                                */
  __IO uint16_t CR1;        /*!< USART Control register 1,                Address offset: 0x0C */
  uint16_t      RESERVED3;  /*!< Reserved, 0x0E                                                */
  __IO uint16_t CR2;        /*!< USART Control register 2,                Address offset: 0x10 */
  uint16_t      RESERVED4;  /*!< Reserved, 0x12                                                */
  __IO uint16_t CR3;        /*!< USART Control register 3,                Address offset: 0x14 */
  uint16_t      RESERVED5;  /*!< Reserved, 0x16                                                */
  __IO uint16_t GTPR;       /*!< USART Guard time and prescaler register, Address offset: 0x18 */
  uint16_t      RESERVED6;  /*!< Reserved, 0x1A                                                */
} USART_TypeDef;
#define PERIPH_BASE           ((unsigned int)0x40000000)
#define APB2PERIPH_BASE       (PERIPH_BASE + 0x00010000)
#define USART1_BASE           (APB2PERIPH_BASE + 0x1000)
#define USART1              ((USART_TypeDef *) USART1_BASE) 

//#pragma import(__use_no_semihosting_swi)

//struct __FILE { int handle; /* Add whatever you need here */ };
//FILE __stdout;
//FILE __stdin;

//int fputc(int ch, FILE *f) {
//	while((USART1->SR&0X40)==0);//Ñ­»··¢ËÍ,Ö±µ½·¢ËÍÍê±Ï   
//	USART1->DR = (unsigned char) ch;      
//	return ch;
//}

//void _sys_exit(int return_code) {
//  while (1);    /* endless loop */
//}

#define DEF_YES 1U
#define DEF_NO 0U
#define ASCII_CHAR_UPPER_A 0x41
#define ASCII_CHAR_UPPER_Z 0x5a
#define ASCII_CHAR_LOWER_A 0x61

#define ASCII_IS_UPPER(c) ((c>=ASCII_CHAR_UPPER_A)&&(c<=ASCII_CHAR_UPPER_Z))? DEF_YES:DEF_NO
#define ASCII_TO_LOWER(c)  (ASCII_IS_UPPER(c)==DEF_YES)? (c+(ASCII_CHAR_LOWER_A-ASCII_CHAR_UPPER_A)):c


#define point int*
//#define NULL (unsigned char*)0  
typedef int* tpoint;   
typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;

uchar datarx(uchar pstr_src); 
void SystemInit (void);
unsigned int CRC16_count(unsigned char *array, unsigned char len);
void swap(uchar** src,uchar** dest);
void (*datafunc)(uchar src,uchar dest);
signed short mycmp(uchar* p1_str,
						 uchar* p2_str,
						 uint len_max);
uchar *mystr_char(const uchar* pstr,
								uint len_max,
								uchar srch_char);
uchar *mystr_last(const uchar* pstr,
									uint len_max,
									uchar srch_char);
uchar *mystr_replace(uchar *pstr,
										uchar char_srch,
										uchar char_replace,
										uchar len_max);

//#pragma pack(2) 

//__packed typedef struct
typedef struct    
{
	unsigned char uc;
	char c;
	unsigned short us;
	short s;
	unsigned int ui;
	int i;
}datast;

 typedef struct
{
	uchar uc;
	uint ui;
//	uchar c;
	ushort us;
}bufst;


typedef struct
{
	uchar a:2; 
	uchar b:1;
	uchar c:1;
	uchar d:1;
	uchar e:1;
	uchar f:1;
	uchar g:1;
	uchar h:1;
}port;

typedef enum
{
	ON=0X100,
	OFF
}KEY;

//#define bufpt ((bufst*)0x20000000)
bufst tsbufst = {0x01,0x04030201,0x0201};
datast tsdatast={0x01,0x01,0x0001,0x0001,0x00000001,0x00000001};
port porta={0,0,0,0,0,0,0,0};
 
#if	!defined(USER_DEF)
char* version  ="test version v0.1"; 
char time[] ={"17-6-28"};
#endif

 volatile int rxbuffer;

int main(void)
{
	KEY ukey;
	volatile unsigned char dataa=0xaa,datab=0xff;
	volatile unsigned char databuf[2][3]={{1,2,3},{4,5,6}};
//	uchar *pta=0x20,*ptb=0x21,**pptc=0x22;
	volatile unsigned char i,flag=0x0a,leth;
//	unsigned char* p = 0x48;
	unsigned char* p = (unsigned char*)4;
	unsigned char cbuf[5] = "0123";
	uchar cbuf1[5]={'0','1','2','3','\0'};
	uchar ibuf[5] ={'5','1','2','3',0x00};//null 0 '\0' '0'
	int inbuf[]={0x0102};
	volatile const point pptr=inbuf;
	volatile const tpoint tpptr=inbuf;
	ukey = OFF;
//	*pptc=0x25;
//	**pptc=0x08;
//	**pptc=databuf[0];
//	**pptc=databuf[1];
//	**pptc=databuf;
//	**pptc=databuf+1;
		
 while(1)
 {
	 START:
	 printf("Aa01");
//	 swap(&pta,&ptb);
//	p = swap;
//	datafunc = swap;
//	(*datafunc)(&pta,&ptb);
	 dataa=ASCII_TO_LOWER('A');
//	 mycmp(cbuf1,ibuf,10); 
	 rxbuffer=  (int)&dataa; 
	 datarx(dataa);
	cbuf1[0]=cbuf[0];
	ibuf[0]=cbuf1[0];
	leth = ukey;
	 leth = sizeof(tsbufst);
	 for(i=0;i<sizeof(cbuf);i++)
	 {
		if(cbuf1[i]!=ibuf[i])
		{
			flag++;break;
		}
		*p=i;
	 }
//	 inbuf[0] = flag;
	 tsdatast.uc = 0x10;
//	 tsbufst.c=0x10;
//	 bufpt->c=0x10;
	 porta.a = 1;
	porta.b = 1;
	porta.c = 1;
porta.d = 1;
porta.e = 1;
porta.f = 1;
porta.g = 1;
porta.h = 1;

	 pptr=inbuf;
	 *tpptr = flag; 
	 leth = sizeof(float);
	 leth++;
	 leth = sizeof(double);
	 dataa=1;
	 datab=-1;
	 if(dataa!=(~datab+1))
	 {
		flag++;
		 CRC16_count(cbuf,sizeof(cbuf)); 
	 }
	 goto START;
 }	 
		
	return 0;
}

void SystemInit (void)
{

}

uchar datarx(uchar pstr_src) 
{
 	rxbuffer=pstr_src;
	rxbuffer++;
	return (rxbuffer);
}

//************************************************
//	 CRC16¼ÆËã    X16+X12+X5+1
//***********************************************
unsigned int CRC16_count(unsigned char *array, unsigned char len)
{
    unsigned char i; 
    unsigned int a;
    unsigned int CRC = 0xffff;
    while(len--) 
    { 
	   a = 0x0001;
       for(i=0; i<8; i++) 
       { 
          if((CRC&0x0001)!=0) 
				 {
						CRC>>=1; 
					CRC^=0x8408;
				 }           
         else CRC>>=1;   
				 
           if((*array&a)!=0) CRC^=0x8408;
				 
		   a <<= 1;                         
       } 
       array++;
	    
    } 
    return ~CRC;
}

void swap(uchar** src,uchar** dest)
{
	uint temp;
	temp =(uint) *src;
	temp =(uint) *dest;

	
}

uint mystrlen(const uchar* pstr,
							uint num)
{
	const uchar* pstr_len;
	uint len;
	
	pstr_len=pstr;
	len=0u;
	
	while((pstr_len!=(uchar*)0)&&
				(*pstr_len!=(uchar)'\0')&&
	      (len<num))
	{
		pstr_len++;
		len++;
	}
	
	return (len);
}

//uchar* mystrcopy(uchar* pstr_dest,
//								 const uchar* pstr_src,
//								 uint num)
//{
//	uchar* pstr_copy_dest;
//	const uchar* pstr_copy_src;
//	uint len;
//	
//	pstr_copy_dest=pstr_dest;
//	pstr_copy_src=pstr_src;
//	len=0u;
//	
//	if((pstr_copy_dest==(uchar*)0)||(pstr_copy_src==(const uchar*)0))return (uchar*)0;
//	
//	while((pstr_copy_dest!=(uchar*)0)&&
//				(pstr_copy_src!=(uchar)'\0')&&
//				(len<num))
//	{
//		*pstr_copy_dest=*pstr_copy_src;
//		pstr_copy_dest++;
//		pstr_copy_src++;
//		len++;
//	}
//	
//	if((pstr_copy_dest==(uchar*)0)||(pstr_copy_src==(const uchar*)0))return (uchar*)0;
//	
//	if(len<num)
//	{
//		*pstr_copy_dest=(uchar)'\0';
//	}
//	
//	return (pstr_dest);
//}

//uchar* mystrcat(uchar* pstr_dest,
//								const uchar* pstr_cat,
//								uint num)
//{
//	uchar* pstr_cat_dest;
//	const uchar* pstr_cat_src;
//	uint leth;
//	
// if(pstr_dest==((uchar*)0))return ((uchar*)0);
//	
// if(num<1)return((uchar*)pstr_dest);
//	
//	pstr_cat_dest=pstr_dest;
//	
//	while((pstr_cat_dest!=(uchar*)0)&&
//				(*pstr_cat_dest!=(uchar)'\0'))
//	{
//		pstr_cat_dest++;
//	}
//	
//	if(pstr_cat_dest==(uchar*)0)return (uchar*)0;
//	
//	pstr_cat_src= pstr_cat;
//	leth=0u;
//	
//	while((pstr_cat_dest!=(uchar*)0)&&
//				(pstr_cat_src!=(uchar*)0)&&
//				(pstr_cat_src!='\0')&&
//				(leth<num))
//	{
//		*pstr_cat_dest=*pstr_cat_src;
//		pstr_cat_dest++;
//		pstr_cat_src++;
//		leth++;
//	}
//	
//	if((pstr_cat_dest==(uchar*)0)&&(pstr_cat_src==(uchar*)0))return (uchar*)0;	
//	
//	*pstr_cat_dest=(uchar)'\0';
//	
//	return (pstr_dest);
//}

//signed short mycmp(uchar* p1_str,
//						 uchar* p2_str,
//						 uint len_max)
//{
//    const  uchar    *p1_str_cmp;
//    const  uchar    *p2_str_cmp;
//    const  uchar    *p1_str_cmp_next;
//    const  uchar    *p2_str_cmp_next;
//           signed short   cmp_val;
//           uint   cmp_len;


//    if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
//        return (0);
//    }

//    if (p1_str == (const uchar *)0) {
//        if (p2_str == (const uchar *)0) {
//            return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
//        }
//        cmp_val = (ushort)0 - (ushort)(*p2_str);
//        return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
//    }
//    if (p2_str == (const uchar *)0) {
//        cmp_val = (uchar)(*p1_str);
//        return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
//    }


//    p1_str_cmp      = p1_str;
//    p2_str_cmp      = p2_str;
//    p1_str_cmp_next = p1_str_cmp;
//    p2_str_cmp_next = p2_str_cmp;
//    p1_str_cmp_next++;
//    p2_str_cmp_next++;
//    cmp_len         = 0u;

//    while ((*p1_str_cmp      == *p2_str_cmp)            &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
//           (*p1_str_cmp      != (      uchar  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
//           ( p1_str_cmp_next != (const uchar *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
//           ( p2_str_cmp_next != (const uchar *)  0 ) &&
//           ( cmp_len         <  (      uint)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
//        p1_str_cmp++;
//        p2_str_cmp++;
//        p1_str_cmp_next++;
//        p2_str_cmp_next++;
//        cmp_len++;
//    }


//    if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
//        return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
//    }

//    if (*p1_str_cmp != *p2_str_cmp) {                           /* If strs NOT identical, ...                           */
//                                                                /* ... calc & rtn char diff  (see Note #3c1).           */
//         cmp_val = (ushort)(*p1_str_cmp) - (ushort)(*p2_str_cmp);

//    } else if (*p1_str_cmp  == (uchar)'\0') {                /* If NULL char(s) found, ...                           */
//         cmp_val = (ushort)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */

//    } else {
//        if (p1_str_cmp_next == (const uchar *)0) {
//            if (p2_str_cmp_next == (const uchar *)0) {       /* If BOTH next str ptrs NULL, ...                      */
//                cmp_val = (ushort)0;                        /* ... rtn 0                       (see Note #3a2A).    */
//            } else {                                            /* If p1_str_cmp_next NULL, ...                         */
//                                                                /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
//                cmp_val = (ushort)0 - (ushort)(*p2_str_cmp_next);
//            }
//        } else {                                                /* If p2_str_cmp_next NULL, ...                         */
//            cmp_val = (ushort)(*p1_str_cmp_next);           /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
//        }
//    }


//    return (cmp_val);

//}

//uchar* mystr_char(const uchar* pstr,
//								uint len_max,
//								uchar srch_char)
//{
//const uchar* pstr_char;
//	uint len_srch;
//	
//	if(pstr==(const uchar*)0){
//		return (uchar*)0;
//	}
//	
//	if(len_max<1){
//		return (uchar*)0;
//	}
//	
//	pstr_char=pstr;
//	len_srch=0u;
//	while((pstr_char!=(const uchar*)0)&&
//				((*pstr_char)!=(uchar)'\0')&&
//				((*pstr_char)!=(uchar)srch_char)&&
//				(len_srch<len_max)){
//		pstr_char++;
//		len_srch++;
//	}
//	
//	if(pstr_char!=(uchar*)0){ 
//		return (uchar*)0;
//	}
//	
//	if(len_srch<len_max){
//		return (uchar*)0;
//	}
//	
//	if((*pstr_char)!=(uchar)srch_char){
//		return (uchar*)0;
//	}
//	
//	return ((uchar*)pstr_char); 
//}

//uchar* mystr_last(const uchar* pstr,
//									uint len_max,
//									uchar srch_char)
//{
//const uchar* pstr_char;
//uint str_len;
//	uint str_len_max;
//	
//	if(pstr!=(const uchar*)0){
//		return (uchar*)0;
//	}
//	
//	if(len_max<1){
//		return (uchar*)0;
//	}
//	
//	pstr_char=pstr;
//	str_len_max=len_max-sizeof((uchar)'\0');//null
//	str_len=mystrlen(pstr_char,str_len_max);
//	pstr_char += str_len;
//	while((pstr_char!=pstr)&&
//				((*pstr_char)!=(uchar)srch_char)){
//		pstr_char--;
//		str_len_max++;
//	}
//	
//	if((*pstr_char)!=(uchar)srch_char){ 
//		return (uchar*)0;
//	}
//	

//return (uchar*)pstr_char;
//}

uchar *mystr_replace(uchar *pstr,
										uchar char_srch,
										uchar char_replace,
										uchar len_max)
{
uchar *pstr_char;
	uchar len;
	
	if(pstr==(uchar *)0){
	return (uchar *)0;
	}
	if(len_max<1){
	return (uchar *)0;
	}
	
	pstr_char=pstr;
	len=len_max;
	while((pstr_char!=(uchar *)0)&&
				(*pstr_char!=(uchar)'\0')&&
				(len>0)){
	if(*pstr_char==char_replace){
		*pstr_char=char_replace;
	}
	pstr_char++;
	len--;
	}

	return pstr;
}












//strcpy;strncat;memcmp;strcmp;strncmp;strcasecmp;strncasecmp;strcoll;strxfrm;strlcat;
//strncpy;strlcpy;strlen;strerror;memset;strtok_r;strstr;strspn;strrchr
//strcat

